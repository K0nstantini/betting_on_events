#pragma version >=0.4.0;

#include "imports/stdlib.fc";
#include "imports/errors.fc";
#include "imports/messages.fc";
#include "imports/op-codes.fc";

(cell, cell, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
            ds~load_dict(), ;; addresses
            ds~load_dict(), ;; supplies
            ds~load_dict(), ;; comissions
    );
}

() save_data(cell addresses, cell supplies, cell comissions) impure inline {
    set_data(begin_cell()
            .store_dict(addresses)
            .store_dict(supplies)
            .store_dict(comissions)
            .end_cell()
    );
}

slice get_ton_storage_addr(cell addresses) inline {
    (slice ton_storage, int success) = addresses.udict_get?(256, "ton_storage");
    throw_unless(error::ton_storage_not_found(), success);
    return ton_storage;
}

slice get_bet_minter_addr(cell addresses) inline {
    (slice bet_minter, int success) = addresses.udict_get?(256, "bet_minter");
    throw_unless(error::bet_minter_not_found(), success);
    return bet_minter;
}

slice get_gov_minter_addr(cell addresses) inline {
    (slice gov_minter, int success) = addresses.udict_get?(256, "gov_minter");
    throw_unless(error::gov_minter_not_found(), success);
    return gov_minter;
}


;; ton storage, bet minter, gov minter
(int, int, int) get_addresses(cell addresses) inline {
    slice ds = supplies.begin_parse();
    return (ds~load_msg_addr(), ds~load_msg_addr(), ds~load_msg_addr());
}

;; ton, bet, gov
(int, int, int) get_supplies(cell supplies) inline {
    slice ds = supplies.begin_parse();
    return (ds~load_coins(), ds~load_coins(), ds~load_coins());
}

cell combine_supplies(int ton_supply, int bet_supply, int gov_supply) inline {
    return begin_cell()
            .store_coins(ton_supply)
            .store_coins(bet_supply)
            .store_coins(gov_supply)
            .end_cell();
}

int get_comission(int amount, slice payload) inline {
    int sign = payload~load_uint(1);
    int num_part = payload~load_uint(32);
    int denom_part = payload~load_uint(32);
    return muldiv(amount, num_part, denom_part);
}

int get_bet_buy_comisssion(int amount, cell comissions) inline {
    (slice payload, int success) = comissions.udict_get?(256, "bet_buy");
    throw_unless(error::bet_buy_comission_not_found(), success);
    return get_comission(amount, payload);
}

int get_bet_sell_comisssion(int amount, cell comissions) inline {
    (slice payload, int success) = comissions.udict_get?(256, "bet_sell");
    throw_unless(error::bet_sell_comission_not_found(), success);
    return get_comission(amount, payload);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    (cell addresses, cell supplies, cell comissions) = load_data();
    (slice ton_storage, slice bet_minter, slice gov_minter) = get_addresses(addresses);
    (int ton_supply, int bet_supply, int gov_supply) = get_supplies(supplies);

    if (op == op::purchased_bet_for_ton()) {
        slice from_address = in_msg_body~load_msg_addr();
        int ton_amount = in_msg_body~load_coins();

        throw_unless(error::wrong_ton_storage_addr(), equal_slices(sender_address, ton_storage));

        int comission = get_bet_buy_comisssion(ton_amount, comissions);

        if (sign == 0) {
            bet_amount = ton_amount - comission;
            throw_unless(error::invalid_bet_amount(), bet_amount > 0);
        } else {
            bet_amount = ton_amount + comission;
        }

        var msg_body = begin_cell()
                .store_uint(op::mint(), 32)
                .store_uint(query_id, 64)
                .store_slice(from_address)
                .store_coins(bet_amount)
                .end_cell();

        messages::send_simple(0, bet_minter, msg_body, MODE_NORMAL);

        supplies = combine_supplies(ton_supply + ton_amount, bet_supply + bet_amount, gov_supply);
        save_data(addresses, supplies, comissions);
        return ();
    }

    if (op == op::sell_bet()) {
        int amount = in_msg_body~load_coins();

        var msg_body = begin_cell()
                .store_uint(op::burn(), 32)
                .store_uint(query_id, 64)
                .store_slice(sender_address)
                .store_coins(amount)
                .end_cell();

        messages::send_simple(0, bet_minter, msg_body, MODE_NORMAL);
        return ();
    }

    if (op == op::burned_bet()) {
        slice from_address = in_msg_body~load_msg_addr();
        int bet_amount = in_msg_body~load_coins();

        int comission = get_bet_sell_comisssion(bet_amount, comissions);

        if (sign == 0) {
            ton_amount = bet_amount - comission;
            throw_unless(error::invalid_ton_amount(), ton_amount > 0);
        } else {
            ton_amount = bet_amount + comission;
        }

        supplies = combine_supplies(ton_supply - ton_amount, bet_supply - bet_amount, gov_supply);
        save_data(addresses, supplies, comissions);
        return ();
    }

    if (op == op::change_comission_bet_buy()) {
        return ();
    }

    if (op == op::change_comission_bet_sell()) {
        return ();
    }

    if (op == op::change_comission_gov_buy()) {
        return ();
    }

    if (op == op::change_comission_gov_sell()) {
        return ();
    }

    if (op == op::change_minter_bet()) {
        return ();
    }

    if (op == op::change_minter_gov()) {
        return ();
    }

    throw(0xffff);
}

(cell, cell, cell) get_data() method_id {
    return load_data();
}
